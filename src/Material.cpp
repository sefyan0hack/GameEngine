#include <core/Material.hpp>
#include <core/Log.hpp>
#include <core/Shader.hpp>
#include <core/Texture.hpp>
#include <glm/glm.hpp>


Material::Material(Shader vertex, Shader fragment)
    : id(glCreateProgram())
    , albedo(nullptr)
{

    glAttachShader(id, vertex.Getid());
    glAttachShader(id, fragment.Getid());

    Link();
    checkProgramLinkStatus();
    Log::Info("Attribs count is {}", AttribsCount());
    Log::Info("Uniforms count is {}", UniformCount());
    DumpAttribs();
    DumpUniforms();
    EnableAttribs();
    Log::Info("{}", *this);
}
Material::Material(std::initializer_list<Shader> shaders)
: id(glCreateProgram())
, albedo(nullptr)
{
    for(const auto &shader : shaders ){
        glAttachShader(id, shader.Getid());
    }
    
    Link();
    checkProgramLinkStatus();
    Log::Info("Attribs count is {}", AttribsCount());
    Log::Info("Uniforms count is {}", UniformCount());
    DumpAttribs();
    DumpUniforms();
    EnableAttribs();
    Log::Info("{}", *this);
}

Material::Material(const Material& other)
    : id(glCreateProgram())
    , Attribs(other.Attribs)
    , Uniforms(other.Uniforms) // dnt forget  to check if the id are the same in the new Programe
    , albedo(nullptr)
{
    for(const auto shader : other.GetShaders() ){
        glAttachShader(id, shader);
    }
    
    Link();
    //no need for checkProgramLinkStatus
    Log::Info("{}", *this);
}
Material::Material(Material&& other)
    : id(std::move(other.id))
    , Attribs(std::move(other.Attribs))
    , Uniforms(std::move(other.Uniforms)) // dnt forget  to check if the id are the same in the new Programe

{
}

Material::~Material()
{
    if(glIsProgram(id) == GL_TRUE) glDeleteProgram(id);
    glUseProgram(0);
}

auto Material::Getid() const -> GLuint
{
    return id;
}

auto Material::Use() const -> void
{
    glUseProgram(id);
    if(albedo)
        albedo->Bind();
}

auto Material::UnUse() const -> void
{
    glUseProgram(0);
    if(albedo)
        albedo->UnBind();
}

auto Material::Link() const -> void
{
    glLinkProgram(id);
}

auto Material::GetUniformLocation(const char *name) const -> GLuint
{
    auto it = Uniforms.find(name);
    
    if (it != Uniforms.end()){
        return it->second;
    }else{
        Log::Error("the Uniform {} not exist", name);
        return static_cast<GLuint>(-1);
    }
}
auto Material::GetAttribLocation(const char *name) const -> GLuint
{
    auto it = Attribs.find(name);
    
    if (it != Attribs.end()){
        return it->second;
    }else{
        Log::Error("the Attrib {} not exist", name);
        return static_cast<GLuint>(-1);
    }
}

auto Material::GetUniformLocation_Prv(const char *name) const -> GLuint
{
    Use();
    GLint location = glGetUniformLocation(id, name);
    if (location == -1) {
        Log::Error("uniform {} doesn't exist!", name);
    }
    return static_cast<GLuint>(location);
}

auto Material::GetAttribLocation_Prv(const char *name) const -> GLuint
{
    Use();
    GLint location = glGetAttribLocation(id, name);
    if (location == -1) {
        Log::Error("Attrib {} doesn't exist!", name);
    }
    return static_cast<GLuint>(location);
}

auto Material::checkProgramLinkStatus() const -> void
{
    GLint success;
    glGetProgramiv(id, GL_LINK_STATUS, &success);
    if (!success) {
        GLchar infoLog[512];
        glGetProgramInfoLog(id, 512, NULL, infoLog);
	    // glDeleteProgram(id);
        Log::Error("PROGRAM LINKING_FAILED {}", infoLog);
    }
}
auto Material::UniformCount() const -> GLint
{
    Log::Expect(glIsProgram(id) == GL_TRUE , "program id {} is not a value generated by OpenGL", id);
    GLint count;
    glGetProgramiv(id, GL_ACTIVE_UNIFORMS, &count);

    if(count <= 0){
        Log::Error("program id is not a value generated by OpenGL.");
    }

    return count;
}
auto Material::AttribsCount() const -> GLint
{
    Log::Expect(glIsProgram(id) == GL_TRUE, "program id {} is not a value generated by OpenGL", id);

    GLint count;
    glGetProgramiv(id, GL_ACTIVE_ATTRIBUTES, &count);

    if(count <= 0){
        Log::Error("program id is not a value generated by OpenGL.");
    }

    return count;
}

auto Material::DumpUniforms() -> void
{
    GLint max_len = 0;
    glGetProgramiv(id, GL_ACTIVE_UNIFORM_MAX_LENGTH, &max_len);
    
    Log::Expect(max_len > 0, "max_len  is not  valid max_len: {}", max_len);

    auto count = UniformCount();
    if(count > 0){

        GLsizei len;
        [[maybe_unused]] GLsizei count_out;
        [[maybe_unused]] GLenum type;

        for(GLint i = 0; i < count; i++){
            std::string Uniform_name(static_cast<size_t>(max_len), '\0');
            glGetActiveUniform(id, i, static_cast<GLsizei>(max_len), &len, &count_out, &type, Uniform_name.data());
            Uniform_name.resize(static_cast<size_t>(len));

            Uniforms[Uniform_name] =  GetUniformLocation_Prv(Uniform_name.c_str());
        }
    }
}

auto Material::DumpAttribs() -> void
{
    GLint max_len = 0;
    glGetProgramiv(id, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &max_len);
    
    Log::Expect(max_len > 0, "max_len  is not  valid max_len: {}", max_len);

    auto count = AttribsCount();
    if(count > 0){
        GLsizei len;
        [[maybe_unused]] GLenum type;

        for(GLint i = 0; i < count; i++){
            std::string attrib_name(static_cast<size_t>(max_len), '\0');
            glGetActiveAttrib(id, i, max_len, &len, nullptr, &type, attrib_name.data());
            attrib_name.resize(static_cast<size_t>(len));

            Attribs[attrib_name] = GetAttribLocation_Prv(attrib_name.c_str());
        }
    }
}

auto Material::Current_Program() -> GLuint{
    GLint prog = 0;
    glGetIntegerv(GL_CURRENT_PROGRAM, &prog);

    if(prog != 0){
        return static_cast<GLuint>(prog);
    }else{
        Log::Error("no programe curnetly bounded");
        return 0;
    }
}

auto Material::GetUniforms() const -> std::map<std::string, GLuint>
{
    return Uniforms;
}
auto Material::GetAttribs() const -> std::map<std::string, GLuint>
{
    return Attribs;
}

auto Material::GetShaders() const -> std::vector<GLuint>
{
    constexpr GLsizei maxShaderCount = 5;
    GLsizei count = 0;
    std::vector<GLuint> shaders(maxShaderCount, 0);
    glGetAttachedShaders(id, maxShaderCount, &count, shaders.data());
    shaders.resize(count);
    return shaders;
}

auto Material::GetTexture() const -> std::shared_ptr<Texture>
{
    return albedo;
}

auto Material::texture(const std::string &name) -> void
{
    albedo = std::make_shared<Texture2D>(name);
}

auto Material::texture(const std::vector<std::string> faces) -> void
{
    albedo = std::make_shared<TextureCubeMap>(faces);
}

auto Material::EnableAttribs() const -> void
{
    GLint enabled = 0;

    for (auto rit = Attribs.rbegin(); rit != Attribs.rend(); ++rit) {
        auto index = rit->second;
        glGetVertexAttribiv(index, GL_VERTEX_ATTRIB_ARRAY_ENABLED, &enabled);

        if(not enabled){
            glEnableVertexAttribArray(index);
        }
    }
}

auto Material::DisableAttribs() const -> void
{
    GLint enabled = 0;

    for (auto rit = Attribs.rbegin(); rit != Attribs.rend(); ++rit) {
        auto index = rit->second;
        glGetVertexAttribiv(index, GL_VERTEX_ATTRIB_ARRAY_ENABLED, &enabled);

        if(enabled)
            glDisableVertexAttribArray(index);
    }
}

///////
template<>
auto Material::SetUniform<GLint>(const std::string& name, const GLint &value) const -> void
{
    auto it = Uniforms.find(name);
    if (it != Uniforms.end()){
        glUniform1i(it->second, value);
    }else{
        Log::Error("the Uniform {} not exist", name);
    }
}
template<>
auto Material::SetUniform<GLfloat>(const std::string& name, const GLfloat &value) const -> void
{
    auto it = Uniforms.find(name);
    if (it != Uniforms.end()){
        glUniform1f(it->second, value);
    }else{
        Log::Error("the Uniform {} not exist", name);
    }
}
template<>
auto Material::SetUniform<GLuint>(const std::string& name, const GLuint &value) const -> void
{
    auto it = Uniforms.find(name);
    if (it != Uniforms.end()){
        glUniform1ui(it->second, value);
    }else{
        Log::Error("the Uniform {} not exist", name);
    }
}
template<>
auto Material::SetUniform<glm::vec3>(const std::string& name, const glm::vec3 &value) const -> void
{
    auto it = Uniforms.find(name);
    if (it != Uniforms.end()){
        glUniform3fv(it->second, 1, &value[0]);
    }else{
        Log::Error("the Uniform {} not exist", name);
    }
}
//
template<>
auto Material::SetUniform<glm::mat2>(const std::string& name, const glm::mat2 &value) const -> void
{
    auto it = Uniforms.find(name);
    if (it != Uniforms.end()){
        glUniformMatrix2fv(it->second, 1, GL_FALSE, &value[0][0]);
    }else{
        Log::Error("the Uniform {} not exist", name);
    }
}
template<>
auto Material::SetUniform<glm::mat3>(const std::string& name, const glm::mat3 &value) const -> void
{
    auto it = Uniforms.find(name);
    if (it != Uniforms.end()){
        glUniformMatrix3fv(it->second, 1, GL_FALSE, &value[0][0]);
    }else{
        Log::Error("the Uniform {} not exist", name);
    }
}
template<>
auto Material::SetUniform<glm::mat4>(const std::string& name, const glm::mat4 &value) const -> void
{
    auto it = Uniforms.find(name);
    if (it != Uniforms.end()){
        glUniformMatrix4fv(it->second, 1, GL_FALSE, &value[0][0]);
    }else{
        Log::Error("the Uniform {} not exist", name);
    }
}
///////

template<>
auto Material::SetUniform<GLint>(const std::string& name, const GLint &value1, const GLint &value2) const -> void
{
    auto it = Uniforms.find(name);
    if (it != Uniforms.end()){
        glUniform2i(it->second, value1, value2);
    }else{
        Log::Error("the Uniform {} not exist", name);
    }
}
template<>
auto Material::SetUniform<GLfloat>(const std::string& name, const GLfloat &value1, const GLfloat &value2) const -> void
{
    auto it = Uniforms.find(name);
    if (it != Uniforms.end()){
        glUniform2f(it->second, value1, value2);
    }else{
        Log::Error("the Uniform {} not exist", name);
    }
}
template<>
auto Material::SetUniform<GLuint>(const std::string& name, const GLuint &value1, const GLuint &value2) const -> void
{
    auto it = Uniforms.find(name);
    if (it != Uniforms.end()){
        glUniform2ui(it->second, value1, value2);
    }else{
        Log::Error("the Uniform {} not exist", name);
    }
}
///////

template<>
auto Material::SetUniform<GLint>(const std::string& name, const GLint &value1, const GLint &value2, const GLint &value3) const -> void
{
    auto it = Uniforms.find(name);
    if (it != Uniforms.end()){
        glUniform3i(it->second, value1, value2, value3);
    }else{
        Log::Error("the Uniform {} not exist", name);
    }
}
template<>
auto Material::SetUniform<GLfloat>(const std::string& name, const GLfloat &value1, const GLfloat &value2, const GLfloat &value3) const -> void
{
    auto it = Uniforms.find(name);
    if (it != Uniforms.end()){
        glUniform3f(it->second, value1, value2, value3);
    }else{
        Log::Error("the Uniform {} not exist", name);
    }
}
template<>
auto Material::SetUniform<GLuint>(const std::string& name, const GLuint &value1, const GLuint &value2, const GLuint &value3) const -> void
{
    auto it = Uniforms.find(name);
    if (it != Uniforms.end()){
        glUniform3ui(it->second, value1, value2, value3);
    }else{
        Log::Error("the Uniform {} not exist", name);
    }
}
///////

template<>
auto Material::SetUniform<GLint>(const std::string& name, const GLint &value1, const GLint &value2, const GLint &value3, const GLint &value4) const -> void
{
    auto it = Uniforms.find(name);
    if (it != Uniforms.end()){
        glUniform4i(it->second, value1, value2, value3, value4);
    }else{
        Log::Error("the Uniform {} not exist", name);
    }
}
template<>
auto Material::SetUniform<GLfloat>(const std::string& name, const GLfloat &value1, const GLfloat &value2, const GLfloat &value3, const GLfloat &value4) const -> void
{
    auto it = Uniforms.find(name);
    if (it != Uniforms.end()){
        glUniform4f(it->second, value1, value2, value3, value4);
    }else{
        Log::Error("the Uniform {} not exist", name);
    }
}
template<>
auto Material::SetUniform<GLuint>(const std::string& name, const GLuint &value1, const GLuint &value2, const GLuint &value3, const GLuint &value4) const -> void
{
    auto it = Uniforms.find(name);
    if (it != Uniforms.end()){
        glUniform4ui(it->second, value1, value2, value3, value4);
    }else{
        Log::Error("the Uniform {} not exist", name);
    }
}