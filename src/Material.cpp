#include <core/Material.hpp>
#include <core/Log.hpp>
#include <core/Shader.hpp>
#include <core/Texture.hpp>
#include <core/Mesh.hpp>
#include <core/ResourceManager.hpp>
#include <glm/glm.hpp>


Material::Material(const Shader& vertex, const Shader& fragment)
    : m_Id(gl::CreateProgram())
    , m_Shaders({vertex, fragment})
    , m_Albedo(nullptr)
    , m_Previd(Current_Program())
{

    for(const auto &shader : m_Shaders ){
        gl::AttachShader(m_Id, shader.id());
    }

    Link();
    checkProgramLinkStatus();
    gl::UseProgram(m_Id);
    Info("Attribs count is {}", AttribsCount());
    Info("Uniforms count is {}", UniformCount());
    DumpAttribs();
    DumpUniforms();
    
}
Material::Material(std::initializer_list<Shader> shaders)
    : m_Id(gl::CreateProgram())
    , m_Shaders(std::move(shaders))
    , m_Albedo(nullptr)
    , m_Previd(Current_Program())
{
    for(const auto &shader : m_Shaders ){
        gl::AttachShader(m_Id, shader.id());
    }
    
    Link();
    checkProgramLinkStatus();
    gl::UseProgram(m_Id);
    DumpAttribs();
    DumpUniforms();
    
}

Material::Material(const Material& other)
    : m_Id(gl::CreateProgram())
    , m_Shaders(other.m_Shaders)
    , m_Albedo(other.m_Albedo)
    , m_Previd(Current_Program())
{
    for(const auto& shader : m_Shaders ){
        gl::AttachShader(m_Id, shader.id());
    }

    Link();
    checkProgramLinkStatus();
    gl::UseProgram(m_Id);
    DumpAttribs();
    DumpUniforms();
    
}
Material::Material(Material&& other) noexcept
    : m_Id(std::exchange(other.m_Id, 0))
    , m_Shaders(std::exchange(other.m_Shaders, {}))
    , m_Attribs(std::exchange(other.m_Attribs, {}))
    , m_Uniforms(std::exchange(other.m_Uniforms, {})) // dnt forget  to check if the id are the same in the new Programe
    , m_Albedo(std::exchange(other.m_Albedo, {}))
    , m_Previd(Current_Program())

{
}

Material::~Material()
{
    gl::DeleteProgram(m_Id);
}

auto Material::id() const noexcept -> GLuint
{
    return m_Id;
}

auto Material::Use() const -> void
{
    m_Previd = Current_Program();
    if(m_Id != 0){
        gl::UseProgram(m_Id); // crache hire even i'm checking the id
        if(m_Albedo)
           m_Albedo->Bind();
    }
}

auto Material::UnUse() const -> void
{
    gl::UseProgram(m_Previd);
    if(m_Albedo)
        m_Albedo->UnBind();
}

auto Material::Link() const -> void
{
    gl::LinkProgram(m_Id);
}

auto Material::UniformLocation(const char *name) const -> GLuint
{
    auto it = m_Uniforms.find(name);
    
    if (it != m_Uniforms.end()){
        return it->second;
    }else{
        Error("the Uniform {} not exist", name);
        return static_cast<GLuint>(-1);
    }
}
auto Material::AttribLocation(const char *name) const -> GLuint
{
    auto it = m_Attribs.find(name);
    
    if (it != m_Attribs.end()){
        return it->second;
    }else{
        Error("the Attrib {} not exist", name);
        return static_cast<GLuint>(-1);
    }
}

auto Material::UniformLocation_Prv(const char *name) const -> GLuint
{
    GLint location = gl::GetUniformLocation(m_Id, name);
    if (location == -1) {
        Error("uniform {} doesn't exist!", name);
    }
    return static_cast<GLuint>(location);
}

auto Material::AttribLocation_Prv(const char *name) const -> GLuint
{
    GLint location = gl::GetAttribLocation(m_Id, name);
    if (location == -1) {
        Error("Attrib {} doesn't exist!", name);
    }
    return static_cast<GLuint>(location);
}

auto Material::checkProgramLinkStatus() const -> void
{
    GLint success = 0;
    gl::GetProgramiv(m_Id, GL_LINK_STATUS, &success);
    if (!success) {
        GLchar infoLog[512];
        std::memset(infoLog, '\0', 512);
        gl::GetProgramInfoLog(m_Id, 512, NULL, infoLog);
        Error("PROGRAM LINKING_FAILED {}", infoLog);
    }
}
auto Material::UniformCount() const -> GLint
{
    GLint count;
    gl::GetProgramiv(m_Id, GL_ACTIVE_UNIFORMS, &count);

    if(count <= 0){
        Error("program id is not a value generated by OpenGL.");
    }

    return count;
}
auto Material::AttribsCount() const -> GLint
{
    GLint count;
    gl::GetProgramiv(m_Id, GL_ACTIVE_ATTRIBUTES, &count);

    if(count <= 0){
        Error("program id is not a value generated by OpenGL.");
    }

    return count;
}

auto Material::DumpUniforms() -> void
{
    GLint max_len = 0;
    gl::GetProgramiv(m_Id, GL_ACTIVE_UNIFORM_MAX_LENGTH, &max_len);
    
    Expect(max_len > 0, "max_len  is not  valid max_len: {}", max_len);

    auto count = UniformCount();
    if(count > 0){

        GLsizei len = 0;
        [[maybe_unused]] GLsizei count_out;
        [[maybe_unused]] GLenum type;

        for(GLint i = 0; i < count; i++){
            std::string Uniform_name(static_cast<size_t>(max_len), '\0');
            gl::GetActiveUniform(m_Id, static_cast<GLuint>(i), static_cast<GLsizei>(max_len), &len, &count_out, &type, Uniform_name.data());
            if(len > 0) Uniform_name.resize(static_cast<size_t>(len));

            m_Uniforms[Uniform_name] =  UniformLocation_Prv(Uniform_name.c_str());
        }
    }
}

auto Material::DumpAttribs() -> void
{
    GLint max_len = 0;
    gl::GetProgramiv(m_Id, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &max_len);
    
    Expect(max_len > 0, "max_len  is not  valid max_len: {}", max_len);

    auto count = AttribsCount();
    if(count > 0){
        GLsizei len = 0;
        [[maybe_unused]] GLenum type;

        for(GLint i = 0; i < count; i++){
            std::string attrib_name(static_cast<size_t>(max_len), '\0');
            gl::GetActiveAttrib(m_Id, static_cast<GLuint>(i), max_len, &len, nullptr, &type, attrib_name.data());
            if(len > 0) attrib_name.resize(static_cast<size_t>(len));

            m_Attribs[attrib_name] = AttribLocation_Prv(attrib_name.c_str());
        }
    }
}

auto Material::Current_Program() -> GLuint
{
    GLint prog = 0;
    gl::GetIntegerv(GL_CURRENT_PROGRAM, &prog);

    return static_cast<GLuint>(prog);
}

auto Material::Uniforms() const noexcept -> const std::map<std::string, GLuint>&
{
    return m_Uniforms;
}
auto Material::Attribs() const noexcept -> const std::map<std::string, GLuint>&
{
    return m_Attribs;
}

auto Material::Shaders() const noexcept -> const std::vector<Shader>&
{
    return m_Shaders;
}

// auto Material::GetShaders() const -> std::vector<GLuint>
// {
//     constexpr GLsizei maxShaderCount = 5;
//     GLsizei count = 0;
//     std::vector<GLuint> shaders(maxShaderCount, 0);
//     gl::GetAttachedShaders(id, maxShaderCount, &count, shaders.data());
//     shaders.resize(count);
//     return shaders;
// }

auto Material::texture() const noexcept-> std::shared_ptr<Texture>
{
    return m_Albedo;
}

auto Material::SetTexture(const std::string &name) -> void
{
    m_Albedo = ResManager.getTexture(name);
}


// auto Material::EnableAttribs() const -> void
// {
//     for(const auto& [aName, aIndex] : Attribs | std::views::reverse){
//         gl::EnableVertexAttribArray(aIndex);
//     }
// }

// auto Material::DisableAttribs() const -> void
// {
//     for(const auto& [aName, aIndex] : Attribs | std::views::reverse){
//         gl::DisableVertexAttribArray(aIndex);
//     }
// }

///////
auto Material::SetUniform(const std::string& name, const GLint &value) const -> void
{
    auto it = m_Uniforms.find(name);
    if (it != m_Uniforms.end()){
        gl::Uniform1i(static_cast<GLint>(it->second), value);
    }else{
        Error("the Uniform {} not exist", name);
    }
}

auto Material::SetUniform(const std::string& name, const GLfloat &value) const -> void
{
    auto it = m_Uniforms.find(name);
    if (it != m_Uniforms.end()){
        gl::Uniform1f(static_cast<GLint>(it->second), value);
    }else{
        Error("the Uniform {} not exist", name);
    }
}
auto Material::SetUniform(const std::string& name, const GLuint &value) const -> void
{
    auto it = m_Uniforms.find(name);
    if (it != m_Uniforms.end()){
        gl::Uniform1ui(static_cast<GLint>(it->second), value);
    }else{
        Error("the Uniform {} not exist", name);
    }
}

auto Material::SetUniform(const std::string& name, const glm::vec2 &value) const -> void
{
    auto it = m_Uniforms.find(name);
    if (it != m_Uniforms.end()){
        gl::Uniform2fv(static_cast<GLint>(it->second), 1, &value[0]);
    }else{
        Error("the Uniform {} not exist", name);
    }
}

auto Material::SetUniform(const std::string& name, const glm::vec3 &value) const -> void
{
    auto it = m_Uniforms.find(name);
    if (it != m_Uniforms.end()){
        gl::Uniform3fv(static_cast<GLint>(it->second), 1, &value[0]);
    }else{
        Error("the Uniform {} not exist", name);
    }
}

auto Material::SetUniform(const std::string& name, const glm::mat2 &value) const -> void
{
    auto it = m_Uniforms.find(name);
    if (it != m_Uniforms.end()){
        gl::UniformMatrix2fv(static_cast<GLint>(it->second), 1, GL_FALSE, &value[0][0]);
    }else{
        Error("the Uniform {} not exist", name);
    }
}

auto Material::SetUniform(const std::string& name, const glm::mat3 &value) const -> void
{
    auto it = m_Uniforms.find(name);
    if (it != m_Uniforms.end()){
        gl::UniformMatrix3fv(static_cast<GLint>(it->second), 1, GL_FALSE, &value[0][0]);
    }else{
        Error("the Uniform {} not exist", name);
    }
}

auto Material::SetUniform(const std::string& name, const glm::mat4 &value) const -> void
{
    auto it = m_Uniforms.find(name);
    if (it != m_Uniforms.end()){
        gl::UniformMatrix4fv(static_cast<GLint>(it->second), 1, GL_FALSE, &value[0][0]);
    }else{
        Error("the Uniform {} not exist", name);
    }
}
///////

auto Material::SetUniform(const std::string& name, const GLint &value1, const GLint &value2) const -> void
{
    auto it = m_Uniforms.find(name);
    if (it != m_Uniforms.end()){
        gl::Uniform2i(static_cast<GLint>(it->second), value1, value2);
    }else{
        Error("the Uniform {} not exist", name);
    }
}

auto Material::SetUniform(const std::string& name, const GLfloat &value1, const GLfloat &value2) const -> void
{
    auto it = m_Uniforms.find(name);
    if (it != m_Uniforms.end()){
        gl::Uniform2f(static_cast<GLint>(it->second), value1, value2);
    }else{
        Error("the Uniform {} not exist", name);
    }
}

auto Material::SetUniform(const std::string& name, const GLuint &value1, const GLuint &value2) const -> void
{
    auto it = m_Uniforms.find(name);
    if (it != m_Uniforms.end()){
        gl::Uniform2ui(static_cast<GLint>(it->second), value1, value2);
    }else{
        Error("the Uniform {} not exist", name);
    }
}
///////

auto Material::SetUniform(const std::string& name, const GLint &value1, const GLint &value2, const GLint &value3) const -> void
{
    auto it = m_Uniforms.find(name);
    if (it != m_Uniforms.end()){
        gl::Uniform3i(static_cast<GLint>(it->second), value1, value2, value3);
    }else{
        Error("the Uniform {} not exist", name);
    }
}

auto Material::SetUniform(const std::string& name, const GLfloat &value1, const GLfloat &value2, const GLfloat &value3) const -> void
{
    auto it = m_Uniforms.find(name);
    if (it != m_Uniforms.end()){
        gl::Uniform3f(static_cast<GLint>(it->second), value1, value2, value3);
    }else{
        Error("the Uniform {} not exist", name);
    }
}

auto Material::SetUniform(const std::string& name, const GLuint &value1, const GLuint &value2, const GLuint &value3) const -> void
{
    auto it = m_Uniforms.find(name);
    if (it != m_Uniforms.end()){
        gl::Uniform3ui(static_cast<GLint>(it->second), value1, value2, value3);
    }else{
        Error("the Uniform {} not exist", name);
    }
}
///////

auto Material::SetUniform(const std::string& name, const GLint &value1, const GLint &value2, const GLint &value3, const GLint &value4) const -> void
{
    auto it = m_Uniforms.find(name);
    if (it != m_Uniforms.end()){
        gl::Uniform4i(static_cast<GLint>(it->second), value1, value2, value3, value4);
    }else{
        Error("the Uniform {} not exist", name);
    }
}

auto Material::SetUniform(const std::string& name, const GLfloat &value1, const GLfloat &value2, const GLfloat &value3, const GLfloat &value4) const -> void
{
    auto it = m_Uniforms.find(name);
    if (it != m_Uniforms.end()){
        gl::Uniform4f(static_cast<GLint>(it->second), value1, value2, value3, value4);
    }else{
        Error("the Uniform {} not exist", name);
    }
}

auto Material::SetUniform(const std::string& name, const GLuint &value1, const GLuint &value2, const GLuint &value3, const GLuint &value4) const -> void
{
    auto it = m_Uniforms.find(name);
    if (it != m_Uniforms.end()){
        gl::Uniform4ui(static_cast<GLint>(it->second), value1, value2, value3, value4);
    }else{
        Error("the Uniform {} not exist", name);
    }
}